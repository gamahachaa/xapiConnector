<?php
/**
 * Haxe source file: C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx
 */

namespace thx;

use \php\Boot;

/**
 * Extension methods for functions with arity 1 (functions that take exactly 1 argument).
 */
class Functions1 {
	/**
	 * `compose` returns a function that calls the first argument function with the result
	 * of the following one.
	 * 
	 * @param \Closure $fa
	 * @param \Closure $fb
	 * 
	 * @return \Closure
	 */
	public static function compose ($fa, $fb) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:85: characters 5-46
		return function ($v) use (&$fb, &$fa) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:85: characters 30-46
			return $fa($fb($v));
		};
	}

	/**
	 * The contravariant functor for Function1<_, B>. Equivalent to compose.
	 * 
	 * @param \Closure $fbc
	 * @param \Closure $fab
	 * 
	 * @return \Closure
	 */
	public static function contramap ($fbc, $fab) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:97: characters 5-45
		return function ($a) use (&$fbc, &$fab) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:97: characters 27-45
			return $fbc($fab($a));
		};
	}

	/**
	 * `join` creates a function that calls the 2 functions passed as arguments in sequence
	 * and passes the same argument value to the both of them.
	 * 
	 * @param \Closure $fa
	 * @param \Closure $fb
	 * 
	 * @return \Closure
	 */
	public static function join ($fa, $fb) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:104: lines 104-107
		return function ($v) use (&$fb, &$fa) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:105: characters 7-12
			$fa($v);
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:106: characters 7-12
			$fb($v);
		};
	}

	/**
	 * The covariant functor for Function1<A, _>
	 * 
	 * @param \Closure $fab
	 * @param \Closure $fbc
	 * 
	 * @return \Closure
	 */
	public static function map ($fab, $fbc) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:91: characters 5-45
		return function ($a) use (&$fbc, &$fab) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:91: characters 27-45
			return $fbc($fab($a));
		};
	}

	/**
	 * `memoize` wraps `callback` and calls it only once storing the result for future needs.
	 * Computed results are stored in an internal map. The keys to this map are generated by
	 * the resolver function that by default directly converts the first argument into a string.
	 * 
	 * @param \Closure $callback
	 * @param \Closure $resolver
	 * 
	 * @return \Closure
	 */
	public static function memoize ($callback, $resolver = null) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:116: lines 116-117
		if (null === $resolver) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:117: characters 7-15
			$resolver = function ($v) {
				#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:117: characters 36-47
				return "" . \Std::string($v);
			};
		}
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:118: characters 15-38
		$map_data = null;
		$this1 = [];
		$map_data = $this1;
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:119: lines 119-126
		return function ($v) use (&$map_data, &$callback, &$resolver) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:120: characters 7-29
			$key = $resolver($v);
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:121: lines 121-122
			if (\array_key_exists($key, $map_data)) {
				#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:122: characters 9-28
				return ($map_data[$key] ?? null);
			}
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:123: characters 7-32
			$result = $callback($v);
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:124: characters 7-27
			$map_data[$key] = $result;
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:125: characters 7-20
			return $result;
		};
	}

	/**
	 * Wraps `callback` in a function that negates its results.
	 * 
	 * @param \Closure $callback
	 * 
	 * @return \Closure
	 */
	public static function negate ($callback) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:133: lines 133-134
		return function ($v) use (&$callback) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:134: characters 7-26
			return !$callback($v);
		};
	}

	/**
	 * `noop` is a function that has no side effects and doesn't return any value.
	 * 
	 * @param mixed $_
	 * 
	 * @return void
	 */
	public static function noop ($_) {
	}

	/**
	 * Returns a function that behaves the same as `callback` but has its arguments inverted.
	 * 
	 * @param \Closure $callback
	 * 
	 * @return \Closure
	 */
	public static function swapArguments ($callback) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:161: lines 161-162
		return function ($a2, $a1) use (&$callback) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:162: characters 7-30
			return $callback($a1, $a2);
		};
	}

	/**
	 * Creates a function that calls `callback` `n` times and returns an array of results.
	 * 
	 * @param int $n
	 * @param \Closure $callback
	 * 
	 * @return \Closure
	 */
	public static function times ($n, $callback) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:145: lines 145-146
		return function ($value) use (&$n, &$callback) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:146: characters 14-67
			$_this = Ints::range($n);
			$result = [];
			$data = $_this->arr;
			$_g_current = 0;
			$_g_length = \count($data);
			$_g_data = $data;
			while ($_g_current < $_g_length) {
				$item = $_g_data[$_g_current++];
				$result[] = $callback($value);
			}
			return \Array_hx::wrap($result);
		};
	}

	/**
	 * Creates a function that calls `callback` `n` times and returns an array of results.
	 * Callback takes an additional argument `index`.
	 * 
	 * @param int $n
	 * @param \Closure $callback
	 * 
	 * @return \Closure
	 */
	public static function timesi ($n, $callback) {
		#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:154: lines 154-155
		return function ($value) use (&$n, &$callback) {
			#C:\HaxeToolkit\haxe\lib\thx,core/0,44,0/src/thx/Functions.hx:155: characters 14-70
			$_this = Ints::range($n);
			$result = [];
			$data = $_this->arr;
			$_g_current = 0;
			$_g_length = \count($data);
			$_g_data = $data;
			while ($_g_current < $_g_length) {
				$item = $_g_data[$_g_current++];
				$result[] = $callback($value, $item);
			}
			return \Array_hx::wrap($result);
		};
	}
}

Boot::registerClass(Functions1::class, 'thx.Functions1');
